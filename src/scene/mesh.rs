//! Management of meshes.

mod components;

pub use components::{
    BoxMeshComp, CircularFrustumMeshComp, ConeMeshComp, CylinderMeshComp, HemisphereMeshComp,
    MeshComp, RectangleMeshComp, SphereMeshComp,
};

use crate::{
    geometry::{PlanarTextureProjection, TextureProjection, TriangleMesh, VertexAttributeSet},
    num::Float,
    rendering::fre,
    scene::{
        MaterialComp, MaterialLibrary, PlanarTextureProjectionComp, RenderResourcesDesynchronized,
    },
};
use anyhow::{anyhow, Result};
use impact_ecs::{archetype::ArchetypeComponentStorage, setup};
use impact_utils::{hash64, stringhash64_newtype};
use lazy_static::lazy_static;
use std::{
    collections::{hash_map::Entry, HashMap},
    fmt::Debug,
    sync::RwLock,
};

stringhash64_newtype!(
    /// Identifier for specific meshes.
    /// Wraps a [`StringHash64`](impact_utils::StringHash64).
    [pub] MeshID
);

/// Repository where [`TriangleMesh`]es are stored under a
/// unique [`MeshID`].
#[derive(Debug, Default)]
pub struct MeshRepository<F: Float> {
    meshes: HashMap<MeshID, TriangleMesh<F>>,
}

lazy_static! {
    /// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
    /// [`TriangleMesh::create_screen_filling_quad`];
    pub static ref SCREEN_FILLING_QUAD_MESH_ID: MeshID = MeshID(hash64!("ScreenFillingQuadMesh"));
}

impl<F: Float> MeshRepository<F> {
    /// Creates a new empty mesh repository.
    pub fn new() -> Self {
        let mut meshes = HashMap::new();

        meshes.insert(
            *SCREEN_FILLING_QUAD_MESH_ID,
            TriangleMesh::create_screen_filling_quad(),
        );

        Self { meshes }
    }

    /// Returns a reference to the [`TriangleMesh`] with the given ID, or
    /// [`None`] if the mesh is not present.
    pub fn get_mesh(&self, mesh_id: MeshID) -> Option<&TriangleMesh<F>> {
        self.meshes.get(&mesh_id)
    }

    /// Returns a mutable reference to the [`TriangleMesh`] with the given ID,
    /// or [`None`] if the mesh is not present.
    pub fn get_mesh_mut(&mut self, mesh_id: MeshID) -> Option<&mut TriangleMesh<F>> {
        self.meshes.get_mut(&mesh_id)
    }

    /// Whether a mesh with the given ID exists in the repository.
    pub fn has_mesh(&self, mesh_id: MeshID) -> bool {
        self.meshes.contains_key(&mesh_id)
    }

    /// Returns a reference to the [`HashMap`] storing all meshes.
    pub fn meshes(&self) -> &HashMap<MeshID, TriangleMesh<F>> {
        &self.meshes
    }

    /// Includes the given mesh in the repository under the given ID.
    ///
    /// # Errors
    /// Returns an error if a mesh with the given ID already exists. The
    /// repository will remain unchanged.
    pub fn add_mesh(&mut self, mesh_id: MeshID, mesh: TriangleMesh<F>) -> Result<()> {
        match self.meshes.entry(mesh_id) {
            Entry::Vacant(entry) => {
                entry.insert(mesh);
                Ok(())
            }
            Entry::Occupied(_) => Err(anyhow!("Mesh {} already present in repository", mesh_id)),
        }
    }

    /// Includes the given mesh in the repository under the given ID, unless a
    /// mesh with the same ID is already present.
    pub fn add_mesh_unless_present(&mut self, mesh_id: MeshID, mesh: TriangleMesh<F>) {
        let _ = self.add_mesh(mesh_id, mesh);
    }
}

impl TriangleMesh<fre> {
    /// Checks if the entity-to-be with the given components has a component
    /// representing a mesh, and if so, generates the mesh and adds it to the
    /// mesh repository if not present, then adds the appropriate mesh component
    /// to the entity.
    pub fn add_mesh_component_for_entity(
        mesh_repository: &RwLock<MeshRepository<fre>>,
        components: &mut ArchetypeComponentStorage,
        desynchronized: &mut RenderResourcesDesynchronized,
    ) -> Result<()> {
        fn create_projection_label(projection: Option<&impl TextureProjection<fre>>) -> String {
            projection
                .as_ref()
                .map_or("None".to_string(), |projection| projection.identifier())
        }

        fn execute_setup_for_rectangle_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            rectangle_mesh: &RectangleMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = rectangle_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_rectangle(
                    rectangle_mesh.extent_x,
                    rectangle_mesh.extent_z,
                );

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_box_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            box_mesh: &BoxMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = box_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_box(
                    box_mesh.extent_x,
                    box_mesh.extent_y,
                    box_mesh.extent_z,
                    box_mesh.front_face_side(),
                );

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_cylinder_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            cylinder_mesh: &CylinderMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = cylinder_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_cylinder(
                    cylinder_mesh.length,
                    cylinder_mesh.diameter,
                    cylinder_mesh.n_circumference_vertices as usize,
                );

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_cone_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            cone_mesh: &ConeMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = cone_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_cone(
                    cone_mesh.length,
                    cone_mesh.max_diameter,
                    cone_mesh.n_circumference_vertices as usize,
                );

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_circular_frustum_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            circular_frustum_mesh: &CircularFrustumMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = circular_frustum_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_circular_frustum(
                    circular_frustum_mesh.length,
                    circular_frustum_mesh.bottom_diameter,
                    circular_frustum_mesh.top_diameter,
                    circular_frustum_mesh.n_circumference_vertices as usize,
                );

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_sphere_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            sphere_mesh: &SphereMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = sphere_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_sphere(sphere_mesh.n_rings as usize);

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        fn execute_setup_for_hemisphere_mesh(
            mesh_repository: &RwLock<MeshRepository<fre>>,
            desynchronized: &mut RenderResourcesDesynchronized,
            hemisphere_mesh: &HemisphereMeshComp,
            projection: Option<&impl TextureProjection<fre>>,
        ) -> MeshComp {
            let mesh_id = hemisphere_mesh.generate_id(create_projection_label(projection));

            if !mesh_repository.read().unwrap().has_mesh(mesh_id) {
                let mut mesh = TriangleMesh::create_hemisphere(hemisphere_mesh.n_rings as usize);

                if let Some(projection) = projection {
                    mesh.generate_texture_coords(projection);
                }

                mesh_repository
                    .write()
                    .unwrap()
                    .add_mesh_unless_present(mesh_id, mesh);

                desynchronized.set_yes();
            }

            MeshComp::new(mesh_id)
        }

        setup!(
            components,
            |rectangle_mesh: &RectangleMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_rectangle_mesh(
                        mesh_repository,
                        desynchronized,
                        rectangle_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_rectangle_mesh(
                        mesh_repository,
                        desynchronized,
                        rectangle_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |box_mesh: &BoxMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_box_mesh(
                        mesh_repository,
                        desynchronized,
                        box_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_box_mesh(
                        mesh_repository,
                        desynchronized,
                        box_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |cylinder_mesh: &CylinderMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_cylinder_mesh(
                        mesh_repository,
                        desynchronized,
                        cylinder_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_cylinder_mesh(
                        mesh_repository,
                        desynchronized,
                        cylinder_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |cone_mesh: &ConeMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_cone_mesh(
                        mesh_repository,
                        desynchronized,
                        cone_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_cone_mesh(
                        mesh_repository,
                        desynchronized,
                        cone_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |circular_frustum_mesh: &CircularFrustumMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_circular_frustum_mesh(
                        mesh_repository,
                        desynchronized,
                        circular_frustum_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_circular_frustum_mesh(
                        mesh_repository,
                        desynchronized,
                        circular_frustum_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |sphere_mesh: &SphereMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_sphere_mesh(
                        mesh_repository,
                        desynchronized,
                        sphere_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_sphere_mesh(
                        mesh_repository,
                        desynchronized,
                        sphere_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        setup!(
            components,
            |hemisphere_mesh: &HemisphereMeshComp,
             planar_projection: Option<&PlanarTextureProjectionComp>|
             -> MeshComp {
                match (planar_projection,) {
                    (Some(planar_projection),) => execute_setup_for_hemisphere_mesh(
                        mesh_repository,
                        desynchronized,
                        hemisphere_mesh,
                        Some(&planar_projection.create_projection()),
                    ),
                    (None,) => execute_setup_for_hemisphere_mesh(
                        mesh_repository,
                        desynchronized,
                        hemisphere_mesh,
                        Option::<&PlanarTextureProjection<_>>::None,
                    ),
                }
            },
            ![MeshComp]
        );

        Ok(())
    }

    /// Checks if the entity-to-be with the given components has a material
    /// component and a component for a mesh that misses vertex attributes
    /// required by the material, and if so, generates the missing vertex
    /// attributes if possible.
    pub fn generate_missing_vertex_properties_for_material(
        mesh_repository: &RwLock<MeshRepository<fre>>,
        material_library: &MaterialLibrary,
        components: &ArchetypeComponentStorage,
    ) {
        setup!(components, |mesh: &MeshComp, material: &MaterialComp| {
            let material_specification = material_library
                .get_material_specification(material.material_handle().material_id())
                .expect("Missing material in library for material component");

            let vertex_attribute_requirements =
                material_specification.vertex_attribute_requirements_for_mesh();

            if vertex_attribute_requirements.contains(VertexAttributeSet::NORMAL_VECTOR) {
                let mesh_repository_readonly = mesh_repository.read().unwrap();
                let mesh_readonly = mesh_repository_readonly
                    .get_mesh(mesh.id)
                    .expect("Missing mesh in repository for mesh component");

                if !mesh_readonly.has_normal_vectors() {
                    log::info!("Generating normal vectors for mesh {}", mesh.id);

                    drop(mesh_repository_readonly); // Release read lock
                    let mut mesh_repository_writable = mesh_repository.write().unwrap();

                    mesh_repository_writable
                        .get_mesh_mut(mesh.id)
                        .unwrap()
                        .generate_smooth_normal_vectors();
                }
            }

            if vertex_attribute_requirements.contains(VertexAttributeSet::TANGENT_SPACE_QUATERNION)
            {
                let mesh_repository_readonly = mesh_repository.read().unwrap();
                let mesh_readonly = mesh_repository_readonly
                    .get_mesh(mesh.id)
                    .expect("Missing mesh in repository for mesh component");

                if !mesh_readonly.has_tangent_space_quaternions() {
                    log::info!("Generating tangent space quaternions for mesh {}", mesh.id);

                    drop(mesh_repository_readonly); // Release read lock
                    let mut mesh_repository_writable = mesh_repository.write().unwrap();

                    mesh_repository_writable
                        .get_mesh_mut(mesh.id)
                        .unwrap()
                        .generate_smooth_tangent_space_quaternions();
                }
            }
        });
    }
}
