//! Triangle and line segment meshes.

pub mod buffer;
pub mod components;
pub mod entity;
pub mod generation;
pub mod texture_projection;
pub mod triangle;

use crate::io;
use anyhow::{Context, Result, anyhow, bail};
use bitflags::bitflags;
use bytemuck::{Pod, Zeroable};
use impact_containers::{HashMap, HashSet};
use impact_geometry::Point;
use impact_math::{Float, hash64, stringhash64_newtype};
use lazy_static::lazy_static;
use log::debug;
use nalgebra::{Point3, Similarity3, UnitQuaternion, UnitVector3, Vector2};
use roc_integration::roc;
use serde::{Deserialize, Serialize};
use std::{
    collections::hash_map::Entry,
    fmt::Debug,
    ops::Neg,
    path::{Path, PathBuf},
};
use texture_projection::{PlanarTextureProjection, TextureProjectionSpecification};
use triangle::TriangleMesh;

stringhash64_newtype!(
    /// Identifier for specific meshes.
    /// Wraps a [`StringHash64`](impact_math::StringHash64).
    #[roc(parents = "Mesh")]
    [pub] MeshID
);

/// Repository where [`TriangleMesh`]es are stored under unique [`MeshID`]s.
#[derive(Debug, Default)]
pub struct MeshRepository {
    triangle_meshes: HashMap<MeshID, TriangleMesh<f32>>,
}

/// Record of the state of a [`MeshRepository`].
#[derive(Clone, Debug)]
pub struct MeshRepositoryState {
    triangle_mesh_ids: HashSet<MeshID>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TriangleMeshSpecification {
    pub name: String,
    pub file_path: PathBuf,
    pub texture_projection: Option<TextureProjectionSpecification>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum TriangleMeshFileFormat {
    Obj,
    Ply,
}

lazy_static! {
    /// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
    /// [`TriangleMesh::create_screen_filling_quad`];
    static ref SCREEN_FILLING_QUAD_MESH_ID: MeshID = MeshID(hash64!("ScreenFillingQuadMesh"));

    /// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
    /// [`TriangleMesh::create_spherical_light_volume`].
    static ref SPHERICAL_LIGHT_VOLUME_MESH_ID: MeshID = MeshID(hash64!("SphericalLightVolume"));

    /// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
    /// [`TriangleMesh::create_box`] with unit extents and front faces on the
    /// inside.
    static ref SKYBOX_MESH_ID: MeshID = MeshID(hash64!("SkyboxMesh"));
}

/// Represents a type of attribute associated with a mesh vertex.
pub trait VertexAttribute: Sized {
    /// Index of this attribute when pieces of data associated with each vertex
    /// attribute are stored together.
    const GLOBAL_INDEX: usize;

    /// The [`VertexAttributeSet`] containing only this attribute.
    const FLAG: VertexAttributeSet = VERTEX_ATTRIBUTE_FLAGS[Self::GLOBAL_INDEX];

    /// A string with the name of this attribute.
    const NAME: &'static str = VERTEX_ATTRIBUTE_NAMES[Self::GLOBAL_INDEX];
}

/// The 3D position of a mesh vertex.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, PartialEq, Zeroable, Pod)]
pub struct VertexPosition<F: Float>(pub Point3<F>);

/// The unit normal vector of a mesh at a vertex position.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, PartialEq, Zeroable, Pod)]
pub struct VertexNormalVector<F: Float>(pub UnitVector3<F>);

/// The (u, v) texture coordinates of a mesh at a vertex position.
#[repr(transparent)]
#[derive(Copy, Clone, Debug, PartialEq, Zeroable, Pod)]
pub struct VertexTextureCoords<F: Float>(pub Vector2<F>);

/// The rotation quaternion from local tangent space to model space at a vertex
/// position. The handedness of the tangent basis is encoded in the sign of the
/// real component (when it is negative, the basis is really left-handed and the
/// y-component of the tangent space vector to transform to model space should
/// be negated before applying the rotation to it).
#[repr(transparent)]
#[derive(Copy, Clone, Debug, PartialEq, Zeroable, Pod)]
pub struct VertexTangentSpaceQuaternion<F: Float>(pub UnitQuaternion<F>);

bitflags! {
    /// Bitflag encoding a set of [`VertexAttribute`]s.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct VertexAttributeSet: u8 {
        const POSITION                 = 1 << 0;
        const NORMAL_VECTOR            = 1 << 1;
        const TEXTURE_COORDS           = 1 << 2;
        const TANGENT_SPACE_QUATERNION = 1 << 3;
    }
}

/// Whether the front faces of a triangle mesh are oriented toward the outside
/// or the inside.
#[roc(parents = "Mesh")]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum FrontFaceSide {
    Outside,
    Inside,
}

/// The total number of available vertex attribute types.
pub const N_VERTEX_ATTRIBUTES: usize = 4;

/// The bitflag of each individual vertex attribute, ordered according to
/// [`VertexAttribute::GLOBAL_INDEX`].
pub const VERTEX_ATTRIBUTE_FLAGS: [VertexAttributeSet; N_VERTEX_ATTRIBUTES] = [
    VertexAttributeSet::POSITION,
    VertexAttributeSet::NORMAL_VECTOR,
    VertexAttributeSet::TEXTURE_COORDS,
    VertexAttributeSet::TANGENT_SPACE_QUATERNION,
];

/// The name of each individual vertex attribute, ordered according to
/// [`VertexAttribute::GLOBAL_INDEX`].
pub const VERTEX_ATTRIBUTE_NAMES: [&str; N_VERTEX_ATTRIBUTES] = [
    "position",
    "normal vector",
    "texture coords",
    "tangent space quaternion",
];

#[roc(dependencies = [impact_math::Hash64])]
impl MeshID {
    #[roc(body = "Hashing.hash_str_64(name)")]
    /// Creates a mesh ID hashed from the given name.
    pub fn from_name(name: &str) -> Self {
        Self(hash64!(name))
    }
}

impl MeshRepository {
    /// Creates a new empty mesh repository.
    pub fn new() -> Self {
        Self {
            triangle_meshes: HashMap::default(),
        }
    }

    /// Generates the meshes that should be available by default and inserts
    /// them into the repository.
    pub fn create_default_meshes(&mut self) {
        self.triangle_meshes.insert(
            screen_filling_quad_mesh_id(),
            TriangleMesh::create_screen_filling_quad(),
        );

        self.triangle_meshes.insert(
            spherical_light_volume_mesh_id(),
            TriangleMesh::create_spherical_light_volume(16),
        );

        self.triangle_meshes.insert(
            skybox_mesh_id(),
            TriangleMesh::create_box(1.0, 1.0, 1.0, FrontFaceSide::Inside),
        );
    }

    /// Loads all meshes in the given specifications and stores them in the
    /// repository
    ///
    /// # Errors
    /// See [`Self::load_specified_mesh`].
    pub fn load_specified_meshes(
        &mut self,
        triangle_mesh_specifications: &[TriangleMeshSpecification],
    ) -> Result<()> {
        for specification in triangle_mesh_specifications {
            self.load_specified_triangle_mesh(specification)?;
        }
        Ok(())
    }

    /// Loads the triangle mesh in the given specification and stores it in the
    /// repository.
    ///
    /// # Errors
    /// Returns an error if:
    /// - Another mesh with the same name is already loaded.
    /// - The file format is not supported.
    /// - The file can not be found or loaded as a mesh.
    pub fn load_specified_triangle_mesh(
        &mut self,
        specification: &TriangleMeshSpecification,
    ) -> Result<()> {
        debug!(
            "Loading triangle mesh `{}` from {}",
            specification.name,
            specification.file_path.display()
        );

        let file_path = &specification.file_path;
        let file_format = specification.resolve_file_format()?;

        let mesh_id = MeshID(hash64!(&specification.name));
        if self.has_triangle_mesh(mesh_id) {
            bail!(
                "Tried to load triangle mesh under already existing name: {}",
                specification.name
            );
        }

        let mut mesh = match file_format {
            TriangleMeshFileFormat::Obj => io::obj::read_mesh_from_obj_file(file_path),
            TriangleMeshFileFormat::Ply => io::ply::read_mesh_from_ply_file(file_path),
        }
        .with_context(|| format!("Failed to load triangle mesh from {}", file_path.display()))?;

        match &specification.texture_projection {
            None => {}
            Some(TextureProjectionSpecification::Planar {
                origin,
                u_vector,
                v_vector,
            }) => {
                let projection = PlanarTextureProjection::new(*origin, *u_vector, *v_vector)
                    .with_context(|| {
                        format!(
                            "Invalid planar texture projection for triangle mesh `{}`",
                            specification.name
                        )
                    })?;
                mesh.generate_texture_coords(&projection);
            }
        }

        self.add_triangle_mesh(mesh_id, mesh)?;

        Ok(())
    }

    /// Records the current state of the repository and returns it as a
    /// [`MeshRepositoryState`].
    pub fn record_state(&self) -> MeshRepositoryState {
        MeshRepositoryState {
            triangle_mesh_ids: self.triangle_meshes.keys().cloned().collect(),
        }
    }

    /// Returns a reference to the [`TriangleMesh`] with the given ID, or
    /// [`None`] if no triangle mesh with that ID is present.
    pub fn get_triangle_mesh(&self, mesh_id: MeshID) -> Option<&TriangleMesh<f32>> {
        self.triangle_meshes.get(&mesh_id)
    }

    /// Returns a mutable reference to the [`TriangleMesh`] with the given ID,
    /// or [`None`] if no triangle mesh with that ID is present.
    pub fn get_triangle_mesh_mut(&mut self, mesh_id: MeshID) -> Option<&mut TriangleMesh<f32>> {
        self.triangle_meshes.get_mut(&mesh_id)
    }

    /// Whether a triangle mesh with the given ID exists in the repository.
    pub fn has_triangle_mesh(&self, mesh_id: MeshID) -> bool {
        self.triangle_meshes.contains_key(&mesh_id)
    }

    /// Returns a reference to the [`HashMap`] storing all triangle meshes.
    pub fn triangle_meshes(&self) -> &HashMap<MeshID, TriangleMesh<f32>> {
        &self.triangle_meshes
    }

    /// Includes the given triangle mesh in the repository under the given ID.
    ///
    /// # Errors Returns an error if a triangle mesh with the given ID already
    /// exists. The repository will remain unchanged.
    pub fn add_triangle_mesh(&mut self, mesh_id: MeshID, mesh: TriangleMesh<f32>) -> Result<()> {
        match self.triangle_meshes.entry(mesh_id) {
            Entry::Vacant(entry) => {
                entry.insert(mesh);
                Ok(())
            }
            Entry::Occupied(_) => Err(anyhow!(
                "Triangle mesh {} already present in repository",
                mesh_id
            )),
        }
    }

    /// Includes the given triangle mesh in the repository under the given ID,
    /// unless a triangle mesh with the same ID is already present.
    pub fn add_triangle_mesh_unless_present(&mut self, mesh_id: MeshID, mesh: TriangleMesh<f32>) {
        let _ = self.add_triangle_mesh(mesh_id, mesh);
    }

    /// Removes the meshes that are not part of the given repository state.
    pub fn reset_to_state(&mut self, state: &MeshRepositoryState) {
        self.triangle_meshes
            .retain(|mesh_id, _| state.triangle_mesh_ids.contains(mesh_id));
    }
}

impl TriangleMeshSpecification {
    /// Resolves all paths in the specification by prepending the given root
    /// path to all paths.
    pub fn resolve_paths(&mut self, root_path: &Path) {
        self.file_path = root_path.join(&self.file_path);
    }

    fn resolve_file_format(&self) -> Result<TriangleMeshFileFormat> {
        let Some(extension) = self.file_path.extension() else {
            bail!(
                "Missing extension for triangle mesh file {}",
                self.file_path.display()
            );
        };
        match &*extension.to_string_lossy().to_lowercase() {
            "obj" => Ok(TriangleMeshFileFormat::Obj),
            "ply" => Ok(TriangleMeshFileFormat::Ply),
            other => Err(anyhow!(
                "Unsupported triangle mesh file format {other} for triangle mesh file {}",
                self.file_path.display()
            )),
        }
    }
}

impl<F: Float> VertexPosition<F> {
    /// Returns the binding location of the GPU vertex buffer for position.
    pub const fn binding_location() -> u32 {
        0
    }

    /// Returns the position scaled by the given scaling factor.
    pub fn scaled(&self, scaling: F) -> Self {
        Self(self.0.coords.scale(scaling).into())
    }

    /// Returns the position transformed by the given similarity transform.
    pub fn transformed(&self, transform: &Similarity3<F>) -> Self {
        Self(transform * self.0)
    }
}

impl<F: Float> VertexNormalVector<F> {
    /// Returns the normal vector transformed by the given similarity transform.
    pub fn transformed(&self, transform: &Similarity3<F>) -> Self {
        Self(transform.isometry.rotation * self.0)
    }
}

impl<F: Float> VertexTangentSpaceQuaternion<F> {
    /// Returns the tangent space quaternion transformed by the given similarity
    /// transform.
    pub fn transformed(&self, transform: &Similarity3<F>) -> Self {
        let mut rotated_tangent_space_quaternion = transform.isometry.rotation * self.0;

        // Preserve encoding of tangent space handedness in real component of
        // tangent space quaternion
        if (rotated_tangent_space_quaternion.w < F::ZERO) != (self.0.w < F::ZERO) {
            rotated_tangent_space_quaternion =
                UnitQuaternion::new_unchecked(rotated_tangent_space_quaternion.neg());
        }

        Self(rotated_tangent_space_quaternion)
    }
}

impl<F: Float> VertexAttribute for VertexPosition<F> {
    const GLOBAL_INDEX: usize = 0;
}

impl<F: Float> VertexAttribute for VertexNormalVector<F> {
    const GLOBAL_INDEX: usize = 1;
}

impl<F: Float> VertexAttribute for VertexTextureCoords<F> {
    const GLOBAL_INDEX: usize = 2;
}

impl<F: Float> VertexAttribute for VertexTangentSpaceQuaternion<F> {
    const GLOBAL_INDEX: usize = 3;
}

impl std::fmt::Display for VertexAttributeSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{{ ")?;
        for (&attribute, name) in VERTEX_ATTRIBUTE_FLAGS
            .iter()
            .zip(VERTEX_ATTRIBUTE_NAMES.iter())
        {
            if self.contains(attribute) {
                write!(f, "`{}` ", name)?;
            }
        }
        write!(f, "}}")
    }
}

impl<F: Float> Point<F> for VertexPosition<F> {
    fn point(&self) -> &Point3<F> {
        &self.0
    }
}

/// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
/// [`TriangleMesh::create_screen_filling_quad`];
pub fn screen_filling_quad_mesh_id() -> MeshID {
    *SCREEN_FILLING_QUAD_MESH_ID
}

/// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
/// [`TriangleMesh::create_spherical_light_volume`].
pub fn spherical_light_volume_mesh_id() -> MeshID {
    *SPHERICAL_LIGHT_VOLUME_MESH_ID
}

/// The ID of a [`TriangleMesh`] in the [`MeshRepository`] generated by
/// [`TriangleMesh::create_box`] with unit extents and front faces on the
/// inside.
pub fn skybox_mesh_id() -> MeshID {
    *SKYBOX_MESH_ID
}
